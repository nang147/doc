---
title: "Learning R"
Author: "NG Kang Nang"
Date: 2 April 2020
output: html_document
---

# Basic

* Assignment values by these operators $=$ / $->$ / $<-$
* Differences between the three operators
* Use ; to seperate codes
* Annotation by #
```{r}
x = 5 
y <- 5 ; x -> z # Make annotation after #
a <- 10 -> b # assign 10 to both a and b
# Compile the following function continuously
print(x) ; print(y) ; print(z) ; print(a) ; print(b)
```

* Create vector
* c() function means combine
* : operator, e.g. (1:5) means c(1, 2, 3, 4, 5)
* Use [] to sepcify a datum in vector
* Can use x$name as alternative if the elements is assigned name
```{r}
vector1 = c(1, 3, 5, 7, 9)
print(vector1) ; print(vector1[2])
vector1[2] = 10 ; print(vector1[2])
```
```{r}
vector2 = (1:5)
print(vector2)
```

* More complicated arguement can be used with []
```{r}
# Repeat elements in pattern of (1, 2, 2, 1) two times 
vector3 = c("X", "Y")[rep(c(1, 2, 2, 1), times = 2)]
print(vector3)
# Remove elements from 2 to 4
vector3 = vector3[-(2:4)]
print(vector3)
```

* seq() function to create sequence
* 4 arguements: from, to, by, length
* seq(from = , to = )
* seq(1, 10) is similar to (1:10)
```{r}
# first two arguements default from and to
seq(1, 30 , by = 5) ; seq(1, 30, length = 6)
```

* seq.int() is more efficient than seq()
* seq_len() can create vector with specific length
* seq_len() can create 0 length vector
* seq_along() can create a vector as the same length of input vector
```{r}
seq_len(5)
seq_len(0)
input <- c("hello", "foo", "bar")
seq_along(input)
```

* Common usage of seq_along()
```{r}
for(i in seq_along(input)) {
  print(input[i])
}
```

* Logical vector
* 3 values: TRUE, FALSE, NA
* TRUE and FALSE will convert to 1 and 0 in normal arithmetic operation
* Created by c() function
* Created by conditions
* Boolean operators
* & AND, | OR, ! NOT
```{r}
lvec1 = c(TRUE, FALSE, TRUE)
lvec2 = vector2 < 3
print(lvec1) ; print(lvec2)
```

* NA means Not Available or Missing Value
* NaN means Not a Number, generated by arithmetic operation
* Check by is.na()
* is.na() return TRUE for noth NA and NAN
* is.nan() only return TRUE for NaN
* Cannot do logical operation
```{r}
na = c(1:3, NA)
is.na(na) # the last element will return TRUE
na == NA # output a vector of NA of the same length
```

* Character vector
* String should be quote by " ", e.g. "string"
* Special characters should be input by \\
* \\n (Enter), \\t (Tab), \\b (Backspace), \\\\ (\\), \\", \\'
* \\a will generate noise, similar to alarm() function
* Special characters can be outputed by cat()
* nchar() function can display the length of the string elements
```{r}
str = c("Hello", "Hi")
class(str)
```

* paste() function
* Combine vector to a single string
* Default seperator is space
* Seperator can be assigned by sep = "string"
* Seperator can be empty be set sep = "" or use paste0() function
```{r}
x = 10
str = paste("x = ", x) # space between = and x
print(str)
str = paste(str, x, sep = "-")
print(str)
str = paste(c("X", "Y"), 1:6, sep = "") # combine element by element
print(str)
```

* toString() function to convert any vector to string
* assign width value to limit the display length
* cat() function output any vector in string
* noquote() function to display string without " "
```{r}
toString((1:5), width = 10)
noquote(str)
```

* Merge vectors in single string by setting collapse value
* Changing collapse value changes the seperator
```{r}
paste(c("red", "green"), "apple")
paste(c("red", "green"), "apple", collapse = ", ")
```

* String vector
* Have to define names by names() function
* Specify elements through string
* Can assign names at the beginning
```{r}
names(vector1) = c("a", "b", "c") # assign corresponding string to the elements
vector2 = c("a" = 1, "b" = 2, "c d" = 3) # assign names to elements 
print(vector1) ; print(vector2)
x = vector1["a"]
print(x)
```

* Use ls() to list variables
* Use ls.str() to list the structure
* browseEnv() can display the variable in browser
* Use rm() to remove variables
```{r}
ls.str() ; rm(list = ls()) ; ls()
```

* Use "aprpos()" function to search for variables
```{r}
apropos("libpath")
```

* .Machine to see the information about the machine
* use $ to specify a variable
* .Machine$double.eps can show the *minimum difference* of distinct values
```{r}
.Machine$double.eps
1 + 2.220446e-16 == 1 ; 1 + 2.220446e-17 == 1
```

# Basic functions

* max(), min(), range(), length()
* Determine the characteristic of the vector
* range() will display the max and min values, the same as c(max(), min())
```{r}
max((1:10)) ; min((1:10)) ; range((1:10)) ; length((1:10))
```

* sum(), prod()
* Calculate the sum or product of all elements of the vector
```{r}
sum((1:10)) ; prod((1:10))
```

* identical() to check the identicalness
```{r}
identical(1, 1.0)
```

* sort(), rev()
* sort from lowest to largest
```{r}
sort((10:1))
```

* rev()
* Reverse the function
```{r}
rev(sort(10:1))
```

* which() function
* Search from the vector
* which.max() and which.min() is more efficient that which(max()) and which(min())
* Only display the location of elements
```{r}
x = (10:20)
which(x %% 7 == 3) ; which.min(x) ; which.max(x)
```

* rep() function
* Repeat elements to form data
* Different pattern to repeat
```{r}
rep1 = rep(x = 1:3, times = 3) # repeat 1:3 3 times
rep2 = rep(x = 1:3, each = 3) # repeat each element 3 times
rep3 = rep(x = 1:3, 3:1) # repeat elements follow pattern 3:1
rep4 = rep(x = 1:3, length.out = 5) # liimt output length to 5
print(rep1) ; print(rep2) ; print(rep3) ; print(rep4)
```

* rep.int() and rep_len() have higher efficiency
```{r}
rep.int(1:4, 3) ; rep_len(1:4, 5)
```

* print() function
* R would automactically call print() function
```{r}
3 * 2 ; print(3 * 2) # the result are the same
```
* R would not automactically call print() in loops or in other functions
```{r}
prime <- c(2, 3, 5, 7, 11, 13)
for (x in prime){x} # not calling print functoin
for (x in prime){print(x)}
```

* formatC() function
* parameters: digits, format, width
```{r}
x = 10 ^ exp(1:3)
formatC(x, digits = 3, format = "e", width = 10)
```

* format() function
* parameters: digits, trim, scientific
```{r}
format(x, digits = 3, trim = TRUE, scientific = TRUE)
```

* prettyNum() function
* parameters: big.mark, small.mark, scientific
```{r}
x = 1 * 10^6
format(x, big.mark = ",", scientific = FALSE)
```

* toupper() and tolower() functions can covert to upper and lower case letter
* substr() and substring() functions
* 3 arguements: string, starting position, ending position
* Only different when handling vector
```{r}
x.strings = c(
  "abcdefghij",
  "ABCDEFGHIJ",
  "1234567890"
)
substr(x.strings, 1:4, 8)
substring(x.strings, 1:4, 8)
```

* strsplit() function to split string
* Default seperate by regular expression (, . & space)
* Set fixed = TRUE to assign seperator
* output will be a list
```{r}
strsplit("foo+bar+Foo,BAR", "+", fixed = TRUE)
# regular expression
strsplit("foo,bar.Foo BAR", "[,. ]")
# assign empty ("") will seperate character by character 
strsplit("abc", "")
```

* getwd() function to get directory
* setwd() function to change director
* file.path() create directory by assigning file name 
* R.home() function to display the home directory of R
* basename() to get the file name without path

# Data class

* Check data class
* Casting: change data class
```{r}
x = 23.96
class(x)
# Casting does not affect the original variable
class(as.character(x)) ; is.character(x)
# Another way to assign class
class(x) = "character" ; is.character(x)
```

* Change vector to data frame
```{r}
y = c(1:5)
print(y) ; as.data.frame(y) ; class(y) ; class(as.data.frame(y))
```

# Factor

* factor(), parameters levels and labels
* levels(), nlevels()
* R will treat data of charactor in data frame as factor
```{r}
x = c("a", "b", "a", "b")
y = factor(x)
y 
levels(y) ; nlevels(y)
y = factor(x, levels = c("b", "a"), labels = c("Beta", "Alpha"))
y
```

* Data in factor can only be kind of levels, otherwise NA will be assigned
* If want to create new level, use levels() function
```{r}
y[1] = "c" # warning
y
levels(y) = c(levels(y), "c")
y[1] = "c"
y
```

* New created levels will be placed at the end
* list() function can help to order
* relevel() to switch to the first
```{r}
levels(y) = list("b" = "Beta", "c" = "c", "a" = "Alpha")
y
relevel(y, "a")
```

* droplevels() function to remove unwanted levels
```{r}
x = c("A", "B", "a", "B")
y = factor(x)
y
y[3] = "A"
unique(y)
y = droplevels(y)
y
```

* Ordered factor
* e.g. excellent > good > bad > worst
* Use ordered() function instead of factor() function
* Or add ordered = TRUE when calling factor() function
```{r}
x = c("worst", "bad", "so-so", "good", "perfect")
y = sample(x, 10, replace = TRUE)
z1 = factor(y, levels = x, ordered = TRUE)
z2 = ordered(y, levels = x)
z1
z2
```

* gl() function to generate factor vector
* 2 key parameters, n = no. of levels , k = no. of appearance of levels
* labels parameter to define the names of levels
* length parameter to control the length of vector
```{r}
gl(n = 2, k = 3)
gl(n = 2, k = 3, labels = c("a", "b"))
gl(n = 2, k = 3, length = 4, labels = c("a", "b"))
```

* Use interaction() to conbine factor vector
* Parameter sep to define the seperator
```{r}
x = gl(2, 2, 8, labels = c("a", "b"))
y = gl(2, 4, 8)
z = gl(4, 2, 8, labels = c("A", "B", "C", "D"))
interaction(x, y)
interaction(x, y, z, sep = "+")
```

# Arithmetic

* Operators
* Basic + - * /
* ^ for exponent
* %% for modulus (remainder only)
* %/% for integer division (exclude remainder)
```{r}
9 %% 2 ; 9 %% 2 
```

* Every variable will be treat as vector
* Calculate element by element
```{r}
y = c(1:4)
3 * y - 2 # 3 and 2 are vectors with length of 1
```

* Shorter vector will repeat itself until the lengths are equal
```{r}
z = (6:9)
y + z # elements of resultant vector will be 1+6, 2+7...
```

* If longer vector length is not multiple of shorter one, there will be missing elements
```{r}
prime + y # there will be warning if v1 is not multiple of v2
```

# Array

* Use matrix() function to create array
* nrow define number of row
* ncol define number of column
* byrow define orientation of array
* dimnames define the names of row and column 
```{r}
matrix(1:6, nrow = 2, ncol = 3)
matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE,
  dimnames = list(c("row1", "row2"),
  c("C.1", "C.2", "C.3")))
```

* Use array() function to create multiple arrays
* dim define dimensions of the arrays
```{r}
array(1:24, dim = c(4, 3, 2), dimnames = list(
  X = c("A1","A2","A3","A4"),
  Y = c("B1", "B2", "B3"), Z = c("C1", "C2")))
```

* ncol() and nrow() functions can check the numbers of row and column
* dim() function to assign new dimensions
* nrow(), ncol(), dim() functions will return NULL for 1 dimension vector
* NROW() and NCOL() functions as alternatives for 1 dimensoin vector
* rownames(), colnames(), dimnames() to get the names

* Combine array
* c() will convert the inputs to 1 dimensional vector
* cbind() and rbind() can merge the arrays according to columns and rows

* Array arithmetics
* t() function to transpose array
* %*% for dot product
* %o% or outer() function for cross product
* solve() function to get the ivnerse
```{r}
1:3 %*% 4:6
1:3 %o% 4:6
m = matrix(c(1, 0, 1, 5, -3, 1, 2, 4, 7), nrow = 3)
m.inv = solve(m)
print(m) ; print(m.inv)
print(m %*% m.inv)
```

# List
* Use list() function to create list
* Any class of elements can be include in list
* Nested list is possible
* Too many nested list may cause problems (over 10k)
* List is dimensionless
```{r}
y.list = list(
  var1 = list( name = "pi", val = pi),
  var2 = list( name = "e", val = exp(1))
)
y.list
y.list$var1$name
y.list[[1]][[1]]
dim(y.list)
```

* Variables are classified as atomic variable or recursive variable
* Atomic variable only allows one class of elements
* Recursive variable allows different class of elements
* Check by is.atomic() and is.recursive() functions
* length() function can check the number of elements
* For nested list, length() only return the length of the first list
* nrow(), NROW(), ncol(), NCOL() can be applied on list
* List cannot do arithmetic calculation directly
```{r}
y.list = list("L1" = c(1:3), "L2" = c(3:5))
y.list$l1 + y.list$l2
```

* Class conversion
* as.list(), as.neumeric(), as.integer()
* If elements in list is not scaler, need to apply unlist() before conversion
```{r}
unlist(y.list)
```

* Use c() function to combine lists
```{r}
c(list(a = 1, b = 2), 3, 4)
```

* NULL
* NULL element can be assign to a list
* The length of NULL is 0
* Use is.null() function to check
* Remove list element by assigning NULL
* Assign NULL as element by list() function
```{r}
y.list$L2 = NULL
y.list
y.list["L1"]= list(NULL)
y.list
```

* Pairlist
* Seldom use
* Empty pairlist will return NULL, while empty list will return empty list
```{r}
pairlist() ; list()
```

# Data Frame

* Use data.frame() function to create data frame
* Must be the same class of elements for each column
* Use row.names to define row name, assign row.names = NULL to use default name
* Use rownames(), colnames(), dimnames() to get the names
* Functions like nrow(), NROW(), dim() can also be applied on data frame
* Use subset() to obtain elements in data frame
* Use cbine(), rbind(), merge() to combine data frame
* Use colSums(), colMeans(), rowSums(), rowMeans() to analyse
* See Analysis section

# Continuous data to seperate data

```{r}
# similar to hist() function to draw histogram
grouped <- cut(iris$Sepal.Length, seq(4.3, 7.9, 4))
head(grouped)
```

# Seperate data to continuous data

```{r}
raw = data.frame(
  x = c("1.23", "4..56", "7.89")
)
as.numeric(raw$x)
# as.numeric(as.character(raw$x)) is less efficient
as.numeric(levels(raw$x))[as.integer(raw$x)]
```

# Loops and sequence control

* if else syntax
* else **must** place right after the } of if
```{r}
# Use runif() to generate evenly distributed random value
x = runif(1)
if (x > 0.5)
{
  message("One!"); 
} else if(x > 0.25)
{
  message("Two!");
} else
{
  message("Three!");
}

# rather simple case with only one command for each condition
if(x > 0.5) "Good" else if(x > 0.25) "OK" else "Bad"
```

* Connot assign vector to if condition, only the first value will be used
* Use ifelse() to handle boolean vector
* 2nd arguement for case of TRUE, 3rd arguement for case of FALSE
```{r}
ifelse(c(TRUE, FALSE, TRUE), "Good", "Bad")
```

* ifelse() function will output corresponding value if arguements are vectors
```{r}
ifelse(rep(c(TRUE, FALSE), 6), 1:3, -1:-6)
```

* switch() function
* For no case is match, can set a return value without assign to any parameter
```{r}
y = "nothing"
switch( y, # ( must place right after switch
  mean = mean(x),
  sd = sd(x),
  median = median(x),
  sum = sum(x),
  "lol") # return it if no case is match
```

* Repeat loop
* Break loop when encounter break
* Set next to skip but not exit the loop
```{r}
x = 0
repeat
{
  x = x + 1
  if (x == 2) next
  message("x = ", x)
  if (x == 4) break
}
```

* While loop is similar to repeat loop
```{r}
x = 0
while (x < 5)
{
  x = x + 1
  if (x == 2) next
  message("x = ", x)
  if (x == 4) break
}
```

* For loop
* For loop can handle any kind of vectors
* Running for loop in R is very inefficient
* Use other alternatives if dealing with big loop
```{r}
x = 0
repeat
{
  x = x + 1
  if (x == 2) next
  message("x = ", x)
  if (x == 4) break
}
```

# Advance loop

* replicate() function
* Similar to rep() excluding the operation include random value
* Every time running replicate is independent
```{r}
rep(rnorm(1), 3) # same output
replicate(3, rnorm(1)) # different output
```

* *apply series functions 
* For the case that cannot rewrite loop to vector operation
* Efficiency unchange, but readability improve

* lapply() function: list apply
* Accept a list and a function, pass every element in list to function
* Return result as list
```{r}
x.list = list(
  a = rgeom(6, prob = 0.1),
  b = rgeom(6, prob = 0.4),
  c = rgeom(6, prob = 0.7)
)
x.list

# to remove repeated elements
# initialize x.uniq
x.uniq <- vector("list", length(x.list))

# Case of normal loop
for ( i in seq_along(x.list) ) {
  # pass each element in x.list to unique() function
  x.uniq[[i]] <- unique(x.list[[i]])
}
# set elements names in x.uniq
names(x.uniq) <- names(x.list)
x.uniq

# Case of using lapply() function
lapply(x.list, unique)
```

* Use matlab package for handle array to have better result
* Other functions like vapply(), sapply(), eapply()...
* vapple() return vector with the same length
* sapply() return as simple result as possible
* eapply() apply on variables in environment
* More or less the same syntax
* *apply series always accept from the first elements in list
* Have to modify accepted function for elements not accept from the first
```{r}
x = 1:3
lapply(x, function(by) seq(2, 10, by = by))
```

* mapply() and Vectorize() function
* tapply() function

* Use plyr package for **ply() series functions
* *1 is input class, \*2 is output class
* llply() means list-to-list, which can replace lapply() function
* laply() means list-to-array
* raply(), rlply(), rdply(), r_ply() to replace replicate()
* ddply() to replace tapply()

# Environment in R

* Concept of environment

# Function

* **Concept of global and local variables**
* Global and local variables may cause difficulty in debugging
* Be aware of defining variables

* Type only function name (without ()) can check the function contents
```{r}
new.env
```

* Use function() function to create function
* Create new function by assign function to a variable
* Assign return() value if neccessary
* Last operation result in function will be default return
```{r}
# can assign default to arguements to return default value
# default value can also be any other functions
# be aware of NA value
myftn = function(x = 8, y = 2){x / y} # {} can omit if only one line
myftn()
# must assign value actually as define
# default order as define if not specify arguements 
myftn(y = 3, x = 6)
# assign return value
myftn = function(x = 8, y = 2)
{
  return(2);
  x / y;
}
myftn()
```

* formals() function can display functions arguements and default value
* Return value of formals() function is a list
* Use args() function as alternatives if require readability
* formalArgs() function to return arguements names only 
* body() function to display the body of function
* deparse(body()) functions to convert entire body to characters
* deparse(body()) will also return indents
```{r}
formals(myftn)
args(myftn)
deparse(body(myftn))
```

* ... arguement
* Other arguement that is not match will pass to internal operation
```{r}
y = c(1.2, 3.5, 6.1, NA)
normalize = function(x,
  m = mean(x, na.rm = na.rm),
  s = sd(x, na.rm = na.rm),
  na.rm = FALSE)
{
  (x - m) / s
}
normalize(y, na.rm = TRUE)

normalize = function(x,
  m = mean(x, ...),
  s = sd(x, ...), ...)
{
  (x - m) / s
}
normalize(y)
normalize(y, na.rm = TRUE)
```

# Help
* demo() function, e.g. demo(graphics)
* ? for particular function, e.g. ?sum
* ?? for key words, e.g. ??plotting
* can use help() and help.search() as alternatives, e.g. help("sum"), help("plotting")
* browseVignettes() to search vignettes of packages
* vignettes("vignettes name", package = "package name") for particular vignettes
* the above functions rely on local documents


# Some useful functions

* Constants
* Inf = Infinity
```{r}
print(pi)
exp(1)
```

* Absolute value
```{r}
abs(-4)
```

* Natural logarithm
```{r}
log(exp(1))
```

* Trigonometric functions
```{r}
sin(pi/2)
```

* Summation
```{r}
sum(1:10)
```

* head() function to list first few elements

# Analysis

* max(), min(), range(), length(), sort() functions
* mean(), median(), var(), sd() functions
* rnorm() function: generate random distributed data
* ecdf() function: empirical cumulative distribution function
* If one arguement is NA, whole result will be NA
* Add parameters na.rm = TRUE to neglect NA

* Summary 
```{r}
data1 = rnorm(30)
summary(data1)
data2 = sample(c(TRUE, FALSE, NA), 30, replace = TRUE)
summary(data2)
data3 = sample(c("A", "B", "C"), 30, replace = TRUE)
data3.factor = factor(data3)
summary(data3.factor)
```

* Create data frame
```{r}
data4 = data.frame(data1, data2, data3)
head(data4, 2) # default number of output is 6
summary(data4)
```

* Use str() function to check the data structure
```{r}
str(data4)
```

* Use unclass() function to print plain contents of the data
* Use attributes() function to 
```{r}
unclass(data3) ; unclass(data3.factor)
attributes(data3) ; attributes(data3.factor)
```

* Use View() function to show data
* Use edit() function to edit the data in View()
* Save edited data in new variable
* Use fix() if want to renew the original data
```{r, eval = 0}
View(data4)
data4.edit = edit(data4)
```

# Import and export data

* Use source() function to import .R script
* Add echo = TRUE if want to display the flow content
* Use savehistory() to save as .R script history
* Use loadhistory() to load history script

* R provided around 100 data set
* Use data() to list
* Those data can be accessed directly
```{r, eval = 0}
data()
```

* .csv file
* Import .csv file data
* Use read.csv() function to import data from .csv file
* Export .csv file
* Use write.csv() function to export data in .csv file
* Use write.table() function can define seperator by sep parameter

* Import .txt file data
* Use scan() function to import data from .txt file
* Can define template for scan() to import data following the template

* Export data
* Use sink() function to save as document
* Use save() function to save variable to disk
* Use load() function to load saved variable

* .rds file
* Use saveRDS() function to save as .rds file for only one variable
* Use readRDS() function to load .rds file data

* Graphics
* Use png() function to export graphics as .png file
* Similar functions: jpeg(), tiff(), bmp()
* Export vector graphics use pdf() or svg() function
* Use postscript() function to export vector graphics for LaTeX

* Use print() before export graphics if using ggplot2 package
* Or use ggsave() from ggplot2 package